{
    "contents" : "\n\n#' @title Oaxaca Decomposition for linear models\n#' \n#' @author Christopher Lee\n#' \n#' @description The function creates a seperate linear regression for each level in the \\code{group}\n#'  and apply the Blinder-Oaxaca Decomposition technique.\n#'  \n#'  @inheritParams lm\n#'  \n#'  @param group The string character for the column in the \\code{data} which identifies different groups.\n#'  The group variable must have at least 2 unique values.\n#'  @param decomposition Which decomposition to use. Possible values are \\code{oaxaca_0}, \\code{oaxaca_1},\n#'  \\code{Cotton}, \\code{Reimer} and \\code{Neumark}. For more information on the meaning of these decompositions\n#'  see '\\code{Details}'.\n#'  @param detailed If \\code{TRUE}, prints the summaries of all models on top of decomposition summaries\n#'  \n#'  @details The gap between the predicted means of different groups will always be calculated so that \n#'  the gap is positive. For the moment, the function cannot show the interactions between the\n#'  endowment gap (explained) and the coefficient gap (unexplained). The function can only handle up to\n#'  decomposition for 3 groups.\n#'  @export\n#'  \noaxaca <- function(formula, data, group, detailed = FALSE, decomposition = 'oaxaca_0'){\n  #Code to allow for the use of formulae in function\n   call <- match.call(expand.dots = FALSE)\n   f <- match(c(\"formula\", \"data\"), names(call), 0L)\n   call <- call[c(1L, f)]\n   call[[1L]] <- quote(stats::model.frame)\n   call <- eval(call, parent.frame())\n   eqn <- formula(formula)\n   call$group <- as.factor(data[,group])\n   #Preparing empty lists for multiple for-loops\n   out <- list()\n   coef <- list()\n   mean <- list()\n   if(length(levels(call$group)) > 1) {\n     for(i in 1:length(levels(call$group)))\n       out$Models[[paste(group, \"=\",\n                         levels(call$group)[i],sep=\"\")]] <- lm(eqn, data=subset(call, group == levels(call$group)[i]))       \n     out$Models[['Pooled']] <- lm(eqn, data)\n    gap <- data.frame(matrix(ncol=1,nrow=length(levels(call$group))))\n    for(i in 1 : length(levels(call$group)))\n       gap[i,] <- mean(out$Models[[i]]$fitted.values)\n    ord <- order(gap, decreasing = TRUE)\n    A <- ord[1]\n    B <- ord[2]\n    C <- ord[3]\n    gap <- mean(out$Models[[A]]$fitted.values) - mean(out$Models[[B]]$fitted.values)\n   \n    for(i in 1 : length(levels(call$group))){\n      for(j in 1 : out$Model[[1]]$rank){\n        coef[[paste('immigrant',levels(call$group)[i],sep=\"\")]][[names(coef(out$Model[[1]]))[j]]] <- \n          coef(out$Model[[i]])[j]\n      }\n      for(j in 2 : out$Model[[1]]$rank){\n        mean[[paste('immigrant',levels(call$group)[i],sep=\"\")]][[names(coef(out$Model[[1]]))[j]]] <- \n          mean(call[j][call$group == levels(call$group)[i],])\n      }\n     }\n    intercept <- function(x){\n      x <- c(1,x)\n      attr(x, \"names\")[1] <- \"(Intercept)\"\n      return(x)\n    }\n    mean <- llply(mean, intercept)\n    tab <- data.frame(Variables = names(coef(out$Model[[1]])))\n    D <- 0\n    if(decomposition == \"oaxaca_0\")\n      D <- 0\n    if(decomposition == \"oaxaca_1\")\n      D <- 1\n    if(decomposition == \"Reimers\")\n      D <- 0.5\n    if(decomposition == \"Cotton\")\n      D <- length(out$Models[[A]]$resid) / length(out$Models[[B]]$resid)\n   for(i in 1 : out$Model[[1]]$rank){\n     tab$Endowment.Gap[i] <- (D * coef[[A]][i] + (1-D)* coef[[B]][i]) * (mean[[A]][i] - mean[[B]][i])\n     tab$Coefficient.Gap[i] <- ((1-D) * mean[[A]][i] + D * mean[[B]][i]) * (coef[[A]][i] - coef[[B]][i])\n   }\n   if(decomposition == \"Neumark\")\n     for (i in 1 : out$Model[[1]]$rank){\n       tab$Endowment.Gap[i] <- coef(out$Models[['Pooled']])[i] * (mean[[A]][i] - mean[[B]][i])\n       tab$Coefficient.Gap[i] <- mean[[A]][i] * (coef[[A]][i] - coef(out$Models[['Pooled']])[i]) + \n         mean[[B]][i] * (coef(out$Models[['Pooled']])[i] - coef[[B]][i])\n     }\n   tab2 <- data.frame(c(mean(out$Model[[A]]$fitted.value), \n                        mean(out$Model[[B]]$fitted.value), gap, \n                        colSums(tab[,-1])[1], colSums(tab[,-1])[2],\n                        colSums(tab[,-1])[1] / gap, colSums(tab[,-1])[2] / gap))\n   rownames(tab2) <- c(paste(\"Mean prediction for\", ls(out$Model[A])),\n                       paste(\"Mean prediction for\", ls(out$Model[B])),\n                       \"Total Gap\",\"- Endowment Gap\",\"- Coefficient Gap\",\n                       \"Explained Gap %\", \"Unexplained Gap %\")\n   colnames(tab2) <- attr(call,'names')[1]\n   out$summary1 <- tab2\n   out$summary2 <- tab\n\n   if(detailed == TRUE){\n     out$Models <- llply(out$Models,summary)\n     return(out)\n   }\n   return(out)\n   } else {\n     stop(\"There are fewer than 2 groups\")\n   }\n}\n",
    "created" : 1403406889773.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "894623946",
    "id" : "258CB108",
    "lastKnownWriteTime" : 1403407965,
    "path" : "~/Desktop/Oaxaca Decomposition/R/oaxaca.R",
    "project_path" : "R/oaxaca.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}